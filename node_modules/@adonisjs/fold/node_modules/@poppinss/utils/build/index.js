import {
  RuntimeException
} from "./chunk-SKNTF5Q5.js";
import {
  isScriptFile,
  naturalSort
} from "./chunk-XFX47BKO.js";
import {
  safeParse,
  safeStringify
} from "./chunk-YFSCSJNE.js";

// src/secret.ts
var REDACTED = "[redacted]";
var Secret = class _Secret {
  /** The secret value */
  #value;
  #keyword;
  constructor(value, redactedKeyword) {
    this.#value = value;
    this.#keyword = redactedKeyword || REDACTED;
  }
  toJSON() {
    return this.#keyword;
  }
  valueOf() {
    return this.#keyword;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.#keyword;
  }
  toLocaleString() {
    return this.#keyword;
  }
  toString() {
    return this.#keyword;
  }
  /**
   * Returns the original value
   */
  release() {
    return this.#value;
  }
  /**
   * Transform the original value and create a new
   * secret from it.
   */
  map(transformFunc) {
    return new _Secret(transformFunc(this.#value));
  }
};

// src/compose.ts
function compose(superclass, ...mixins) {
  return mixins.reduce((c, mixin) => mixin(c), superclass);
}

// src/flatten.ts
import { flattie } from "flattie";
function flatten(input, glue, keepNullish) {
  return flattie(input, glue, keepNullish);
}

// src/safe_equal.ts
import { Buffer } from "buffer";
import { timingSafeEqual } from "crypto";
function safeEqual(trustedValue, userInput) {
  if (typeof trustedValue === "string" && typeof userInput === "string") {
    const trustedLength = Buffer.byteLength(trustedValue);
    const trustedValueBuffer = Buffer.alloc(trustedLength, 0, "utf-8");
    trustedValueBuffer.write(trustedValue);
    const userValueBuffer = Buffer.alloc(trustedLength, 0, "utf-8");
    userValueBuffer.write(userInput);
    return timingSafeEqual(trustedValueBuffer, userValueBuffer) && trustedLength === Buffer.byteLength(userInput);
  }
  return timingSafeEqual(
    Buffer.from(trustedValue),
    Buffer.from(userInput)
  );
}

// src/import_default.ts
async function importDefault(importFn, filePath) {
  const moduleExports = await importFn();
  if (!("default" in moduleExports)) {
    const errorMessage = filePath ? `Missing "export default" in module "${filePath}"` : `Missing "export default" from lazy import "${importFn}"`;
    throw new RuntimeException(errorMessage, {
      cause: {
        source: importFn
      }
    });
  }
  return moduleExports.default;
}

// src/message_builder.ts
import string from "@poppinss/string";
var MessageBuilder = class {
  #getExpiryDate(expiresIn) {
    if (!expiresIn) {
      return void 0;
    }
    const expiryMs = string.milliseconds.parse(expiresIn);
    return new Date(Date.now() + expiryMs);
  }
  /**
   * Returns a boolean telling, if message has been expired or not
   */
  #isExpired(message) {
    if (!message.expiryDate) {
      return false;
    }
    const expiryDate = new Date(message.expiryDate);
    return Number.isNaN(expiryDate.getTime()) || expiryDate < /* @__PURE__ */ new Date();
  }
  /**
   * Builds a message by encoding expiry date and purpose inside it.
   */
  build(message, expiresIn, purpose) {
    const expiryDate = this.#getExpiryDate(expiresIn);
    return safeStringify({ message, purpose, expiryDate });
  }
  /**
   * Verifies the message for expiry and purpose.
   */
  verify(message, purpose) {
    const parsed = safeParse(message);
    if (typeof parsed !== "object" || !parsed) {
      return null;
    }
    if (!parsed.message) {
      return null;
    }
    if (parsed.purpose !== purpose) {
      return null;
    }
    if (this.#isExpired(parsed)) {
      return null;
    }
    return parsed.message;
  }
};

// src/define_static_property.ts
import lodash from "@poppinss/utils/lodash";
function defineStaticProperty(self, propertyName, {
  initialValue,
  strategy
}) {
  if (!self.hasOwnProperty(propertyName)) {
    const value = self[propertyName];
    if (strategy === "define" || value === void 0) {
      Object.defineProperty(self, propertyName, {
        value: initialValue,
        configurable: true,
        enumerable: true,
        writable: true
      });
      return;
    }
    Object.defineProperty(self, propertyName, {
      value: typeof strategy === "function" ? strategy(value) : lodash.cloneDeep(value),
      configurable: true,
      enumerable: true,
      writable: true
    });
  }
}
export {
  MessageBuilder,
  Secret,
  compose,
  defineStaticProperty,
  flatten,
  importDefault,
  isScriptFile,
  naturalSort,
  safeEqual
};
